
# 1_factorize.py

Необходимо написать комплект тестов используя модуль unittest стандартной библиотеки Python. Имя тестового класса - **TestFactorize**.  

Описание тестов:

- **test_wrong_types_raise_exception** - проверяет, что передаваемый в функцию аргумент типа float или str вызывает исключение **TypeError**. Тестовый набор входных данных:  'string',  1.5
- **test_negative** - проверяет, что передача в функцию factorize отрицательного числа вызывает исключение **ValueError**. Тестовый набор входных данных:   -1,  -10,  -100
- **test_zero_and_one_cases** - проверяет, что при передаче в функцию целых чисел 0 и 1, возвращаются соответственно кортежи (0,) и (1,). Набор тестовых данных: 0 → (0, ),  1 → (1, )
- **test_simple_numbers** - что для простых чисел возвращается кортеж, содержащий одно данное число. Набор тестовых данных: 3 → (3, ),  13 → (13, ),   29 → (29, )
- **test_two_simple_multipliers** — проверяет случаи, когда передаются числа для которых функция factorize возвращает кортеж с числом элементов равным 2. Набор тестовых данных: 6 → (2, 3),   26 → (2, 13),   121 --> (11, 11)
**test_many_multipliers** - проверяет случаи, когда передаются числа для которых функция factorize возвращает кортеж с числом элементов больше 2. Набор тестовых данных: 1001 → (7, 11, 13) ,   9699690 → (2, 3, 5, 7, 11, 13, 17, 19)


# 2_base.py

В этом задании вам даны 3 класса A, B, C, имеющие сходный (но не одинаковый) интерфейс. Вам необходимо создать абстрактный базовый класс Base и построить корректную схему наследования.

При выполнении следует избегать дублирования кода, и стараться следовать SOLID принципам ООП.

Кроме того, рекомендуется самостоятельно тестировать код перед отправкой, а также при написании следовать стандарту PEP 8.


# 3_screensaver_test.py

1. Изучить документацию к библиотеке pygame и код программы. Понять механизм работы программы (как происходит отрисовка кривой, перерасчет точек сглаживания и другие нюансы реализации программы)

2. Провести рефакторниг кода, переписать программу в ООП стиле с использованием классов и наследования.

- Реализовать класс 2-мерных векторов Vec2d [1]. В классе следует определить методы для основных математических операций, необходимых для работы с вектором: Vec2d.__add__ (сумма), Vec2d.__sub__ (разность), Vec2d.__mul__ (произведение на число). А также добавить возможность вычислять длину вектора с использованием функции len(a) и метод int_pair, который возвращает кортеж из двух целых чисел (текущие координаты вектора).
- Реализовать класс замкнутых ломаных Polyline с методами отвечающими за добавление в ломаную точки (Vec2d) c её скоростью, пересчёт координат точек (set_points) и отрисовку ломаной (draw_points). Арифметические действия с векторами должны быть реализованы с помощью операторов, а не через вызовы соответствующих методов.
- Реализовать класс Knot (наследник класса Polyline), в котором добавление и пересчёт координат инициируют вызов функции get_knot для расчёта точек кривой по добавляемым «опорным» точкам [2].
- Все классы должны быть самостоятельными и не использовать внешние функции.
- Реализовать дополнительный функционал (выполнение требований этого пункта предоставляет возможность потренировать свои навыки программирования и позволяет получить дополнительные баллы в этом задании). К дополнительным задачам относятся: реализовать возможность удаления «опорной» точки из кривой, реализовать возможность отрисовки на экране нескольких кривых, реализовать возможность ускорения/замедления скорости движения кривой(-ых).